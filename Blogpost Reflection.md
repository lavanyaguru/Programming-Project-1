When I first read the spec of the project, I thought "okay" and had a general idea of Question 1. The second part seemed interesting as well but I brainstormed many ways to do the first part of the first question. When I saw that you had to program the solution in Go, I got a little anxious since I wasn't really familiar with that language. 

When I first started coding, I broke it down into parts because the algorithm wasn't all that difficult but putting it into Go's syntax was the challenge. Right off the bat, I thought it was a lot of fun reading the command line arguments because Go allows you to read the whole command in a line, just the arguments, and index the argument. Learning the syntax didn't seem all that bad, there were some great tutorials online! I started to read more about Go and what it's used for before doing anything more. Doing more research, I discovered that Go is a very simple yet powerful language for pragmatic software engineering. In the real world of IT, complex, large-scale software is written by large teams of developers. These developers typically have varying skill levels, from juniors up to seniors. You need a language tool that everybody can easily learn and master. You need a tool that does not impede the fast pace of development with long compile times and a difficult debugging process. You need a language that encourages readability and comprehension, you need the safety and reliability of static typing, but not the overbearing ceremony and complexity that come with a language like C++ or C. Go delivers on all counts. I learned that Google uses Go for its vast internal server infrastructure. The engineering problems that Google faces are the same ones that plague every other enterprise around the globe! I also noticed that Go compiles and executes very quickly giving the language a dynamic feel. In that sense, it’s a fun language to use. This made me that much more excited to learn how to code in Go. 

and by doing this, I wasn't as frustrated when getting errors. Yes, the syntax rules are a bit weird with ":=" and how you need the "else" for the "if-else" to be on the same line as the last bracket from the "if," but once I caught on, it wasn't as hard as I expected to. One tactic that helped me was that I coded the algorithm in Java first then translated it into Go syntax. By doing so, I learned many crucial Go rules and even learned how to use their String Builder. There was definitely a lot of trial and error but this was the first time in a long time where I sat down and enjoyed coding and learning a new language. After taking all those classes in C, a part of me lost the vision to see the beauty in coding because I felt drained at the time but it's slowly coming back. Overall, I had a great time learning a new language and it brought me a good challenge. I’m glad to share that I have gained sufficient knowledge to make programs in Go look forward to coding more in this language to expand my skills! 
